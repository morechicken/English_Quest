<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Spell Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <link rel="manifest" href="../manifest.json">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script src="../data/word_data.js"></script>
    <script src="../js/app.js"></script>

    <style>
        :root {
            --primary-color: #00f2ff;
            --secondary-color: #bd00ff;
            --error-color: #ff0055;
            --bg-color: #0f172a;
        }

        body {
            margin: 0; padding: 0; width: 100vw; height: 100vh; height: 100dvh;
            overflow: hidden; font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-color) !important;
            background: radial-gradient(circle at 50% 120%, #1e293b, #020617 80%) !important;
            color: white; touch-action: none; user-select: none;
            -webkit-user-select: none; -webkit-tap-highlight-color: transparent;
            /* フェードアニメーション用 */
            opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        body.loaded { opacity: 1; }

        #game-container {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; flex-direction: column;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            z-index: 10;
        }

        #top-ui {
            flex: 0 0 auto; padding: 10px 20px;
            background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; align-items: center; z-index: 50;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); width: 100%;
        }

        #play-area {
            flex: 1 1 auto; position: relative; width: 100%; height: 100%;
            overflow: hidden;
        }

        /* タイル（親要素：位置制御） */
        .tile-wrapper {
            position: absolute; width: 60px; height: 60px; top: 0; left: 0;
            will-change: transform; touch-action: none;
            display: flex; justify-content: center; align-items: center;
        }

        /* タイル（子要素：見た目・アニメーション） */
        .letter-visual {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; font-weight: 900; color: #ffffff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background-color: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: border-color 0.2s, background-color 0.2s, box-shadow 0.2s;
        }

        /* ターゲット強調 */
        .is-target .letter-visual {
            border-color: var(--primary-color);
            box-shadow: 0 0 30px var(--primary-color), inset 0 0 10px rgba(0, 242, 255, 0.3);
            background-color: rgba(0, 242, 255, 0.2);
            animation: pulse 0.8s infinite alternate;
        }
        .tile-wrapper.is-target { z-index: 100; }

        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.15); } }

        /* 完了スロット */
        .slot-container {
            display: flex; justify-content: center; flex-wrap: wrap;
            gap: 4px; margin-top: 8px;
        }
        .slot {
            width: 20px; height: 4px;
            background: rgba(255, 255, 255, 0.2); border-radius: 2px; transition: all 0.3s;
        }
        .slot.filled { background: var(--primary-color); box-shadow: 0 0 8px var(--primary-color); }
        .slot.active { background: white; transform: scaleY(2); }

        #timer-display {
            font-family: 'Roboto Mono', monospace; font-size: 1.5rem; color: var(--primary-color);
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%); font-weight: bold;
        }
        #target-word-display { font-size: 1.5rem; font-weight: bold; letter-spacing: 0.1em; }

        #player-orb {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 64px; height: 64px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, var(--primary-color), #0f172a);
            box-shadow: 0 0 30px var(--primary-color); z-index: 30; pointer-events: none;
        }

        .laser-beam {
            position: fixed; height: 6px; background: var(--primary-color);
            transform-origin: left center; pointer-events: none; z-index: 50;
            box-shadow: 0 0 15px var(--primary-color); border-radius: 3px;
        }
        
        #flash-overlay {
            position: fixed; inset: 0; background-color: var(--error-color);
            opacity: 0; pointer-events: none; z-index: 100; transition: opacity 0.1s;
        }
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-3px, 0, 0); }
            20%, 80% { transform: translate3d(6px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }
        .particle { position: fixed; pointer-events: none; border-radius: 50%; z-index: 80; }
        
        #result-overlay {
            position: fixed; inset: 0; background: rgba(15, 23, 42, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        /* 綴り表示オーバーレイ */
        #spell-reveal-overlay {
            position: fixed; inset: 0; background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 300; opacity: 0; pointer-events: none; transition: opacity 0.4s; cursor: pointer;
        }
        #spell-reveal-overlay.show { opacity: 1; pointer-events: auto; }
        #spell-reveal-content { display: flex; gap: 0.5rem; }
        .revealed-char {
            font-size: 6rem; font-weight: 900;
            color: var(--primary-color);
            text-shadow: 0 0 25px var(--primary-color);
            opacity: 0;
            transform: translateY(20px);
            animation: revealChar 0.5s forwards cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes revealChar {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>

    <!-- BGM再生用のaudio要素 -->
    <audio id="bgm" loop></audio>

    <div id="flash-overlay"></div>

    <div id="game-container">
        <div id="top-ui">
            <div id="timer-display">0.00</div>
            <div id="target-word-display"></div>
            <div id="slots" class="slot-container"></div>
        </div>

        <div id="play-area"></div>
        <div id="player-orb"></div>
    </div>

    <div id="result-overlay">
        <div class="text-cyan-400 font-bold tracking-widest mb-2">COMPLETE</div>
        <div id="final-time" class="text-6xl font-mono text-white font-bold mb-8">0.00</div>
        <button onclick="location.reload()" class="px-8 py-3 bg-cyan-500 text-white font-bold rounded-full shadow-lg active:scale-95 transition">RETRY</button>
        <button id="next-btn" class="mt-4 px-8 py-3 bg-gray-700 text-white font-bold rounded-full shadow-lg active:scale-95 transition">NEXT / BACK</button>
    </div>

    <!-- 綴り表示用オーバーレイ -->
    <div id="spell-reveal-overlay">
        <div id="spell-reveal-content"></div>
    </div>

    <script>
        // 1. データ取得（app.jsが先に読み込まれているので動く）
        const wordData = getCurrentWordData();
        
        // データがない場合はリストに戻す
        if (!wordData) {
            alert("データが見つかりません。");
            window.location.href = "../list.html";
        }

        // 2. 定数の上書き
        const TARGET_WORD = wordData.word;
        const LETTERS = wordData.word.split('');
        
        // DOM要素
        const playArea = document.getElementById('play-area');
        const slotsContainer = document.getElementById('slots');
        const playerOrb = document.getElementById('player-orb');
        const flashOverlay = document.getElementById('flash-overlay');
        const timerDisplay = document.getElementById('timer-display');
        const resultOverlay = document.getElementById('result-overlay');
        const finalTimeDisplay = document.getElementById('final-time');
        const container = document.getElementById('game-container');
        const targetWordDisplay = document.getElementById('target-word-display');
        
        // 戻るボタンの設定
        document.getElementById('next-btn').onclick = () => {
            goTo('../cockpit.html', wordData.id);
        };

        let currentIndex = 0;
        let tiles = [];
        let isGameActive = false;
        let startTime = 0;
        let timerInterval = null;

        // === Audio ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if (type === 'shoot') {
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(150, t + 0.15);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
            } else if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.linearRampToValueAtTime(1000, t + 0.1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t); osc.stop(t + 0.2);
            } else if (type === 'complete') {
                osc.type = 'sine';
                [0, 0.2, 0.4].forEach((d, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.connect(g); g.connect(audioCtx.destination);
                    o.frequency.value = 523 + (i * 100);
                    g.gain.setValueAtTime(0.1, t+d);
                    g.gain.linearRampToValueAtTime(0, t+d+1);
                    o.start(t+d); o.stop(t+d+1);
                });
            }
        }

        // === Timer ===
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                timerDisplay.textContent = ((Date.now() - startTime) / 1000).toFixed(2);
            }, 30);
        }
        function stopTimer() {
            clearInterval(timerInterval);
            finalTimeDisplay.textContent = ((Date.now() - startTime) / 1000).toFixed(2);
        }

        // === Init ===
        function init() {
            // playAreaのサイズ計算を確実にする
            let width = playArea.clientWidth;
            let height = playArea.clientHeight;

            if (!width || width < 100) width = window.innerWidth;
            if (!height || height < 100) height = window.innerHeight * 0.7;

            targetWordDisplay.textContent = TARGET_WORD;
            createSlots();
            createTiles(width, height);
            updateNextTargets();
            
            isGameActive = true;
            startTimer();
            gameLoop();
        }

        function createSlots() {
            slotsContainer.innerHTML = '';
            LETTERS.forEach(() => {
                const s = document.createElement('div');
                s.className = 'slot';
                slotsContainer.appendChild(s);
            });
        }

        function createTiles(areaW, areaH) {
            playArea.innerHTML = '';
            tiles = [];
            const margin = 70; 
            const maxX = Math.max(areaW - margin, 100); 
            const maxY = Math.max(areaH - margin, 100);

            LETTERS.forEach(char => {
                // 親要素 (wrapper): JSで位置制御
                const wrapper = document.createElement('div');
                wrapper.className = 'tile-wrapper';

                // 子要素 (visual): CSSで見た目と拡大アニメーション制御
                const visual = document.createElement('div');
                visual.className = 'letter-visual';
                visual.textContent = char;
                
                wrapper.appendChild(visual);

                const startX = Math.random() * maxX;
                const startY = Math.random() * maxY;
                
                // JSでの初期配置
                wrapper.style.transform = `translate(${startX}px, ${startY}px)`;

                const tileData = {
                    wrapper: wrapper,
                    visual: visual,
                    char: char,
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    isCaptured: false
                };
                
                // タップ判定は親要素で
                wrapper.addEventListener('pointerdown', (e) => handleTap(e, tileData));
                playArea.appendChild(wrapper);
                tiles.push(tileData);
            });
        }

        // === Loop ===
        function gameLoop() {
            if (!isGameActive) return;

            let w = playArea.clientWidth || window.innerWidth;
            let h = playArea.clientHeight || (window.innerHeight * 0.7);
            const maxX = Math.max(w - 60, 50);
            const maxY = Math.max(h - 60, 50);

            tiles.forEach(t => {
                if (t.isCaptured) return;

                t.x += t.vx;
                t.y += t.vy;

                if (t.x <= 0) { t.x = 0; t.vx *= -1; }
                if (t.x >= maxX) { t.x = maxX; t.vx *= -1; }
                if (t.y <= 0) { t.y = 0; t.vy *= -1; }
                if (t.y >= maxY) { t.y = maxY; t.vy *= -1; }

                // 親要素のみを動かす
                t.wrapper.style.transform = `translate(${t.x}px, ${t.y}px)`;
            });
            requestAnimationFrame(gameLoop);
        }

        function updateNextTargets() {
            const targetChar = LETTERS[currentIndex];
            
            Array.from(slotsContainer.children).forEach((slot, i) => {
                if (i === currentIndex) slot.classList.add('active');
                else slot.classList.remove('active');
            });

            tiles.forEach(t => {
                if(t.isCaptured) return;
                // クラスの付け替えは親要素に対して行う
                if(t.char === targetChar) {
                    t.wrapper.classList.add('is-target');
                } else {
                    t.wrapper.classList.remove('is-target');
                }
            });
        }

        function handleTap(e, tileData) {
            e.preventDefault(); e.stopPropagation();
            if (!isGameActive || tileData.isCaptured) return;

            if (tileData.char === LETTERS[currentIndex]) {
                success(tileData);
            } else {
                fail();
            }
        }

        function success(tileData) {
            playSound('shoot');
            
            const pRect = playerOrb.getBoundingClientRect();
            const tRect = tileData.wrapper.getBoundingClientRect(); // 親の座標取得
            createLaser(pRect.left+32, pRect.top+32, tRect.left+30, tRect.top+30);

            setTimeout(() => {
                playSound('hit');
                tileData.isCaptured = true;
                tileData.wrapper.classList.remove('is-target');
                createParticles(tileData.x+30, tileData.y+30);

                const slot = slotsContainer.children[currentIndex];
                const sRect = slot.getBoundingClientRect();
                const cRect = tileData.wrapper.getBoundingClientRect();
                
                const dx = sRect.left - cRect.left;
                const dy = sRect.top - cRect.top;

                // 吸い込み演出
                tileData.wrapper.style.transition = 'transform 0.3s ease-in, opacity 0.3s';
                tileData.wrapper.style.transform = `translate(${tileData.x + dx}px, ${tileData.y + dy}px) scale(0.2)`;
                tileData.wrapper.style.opacity = 0.2;

                setTimeout(() => {
                    slot.classList.add('filled');
                    slot.classList.remove('active');
                    tileData.wrapper.style.display = 'none';
                    
                    currentIndex++;
                    if (currentIndex >= LETTERS.length) {
                        gameComplete();
                    } else {
                        updateNextTargets();
                    }
                }, 300);
            }, 50);
        }

        function fail() {
            playSound('error');
            container.classList.remove('shake');
            void container.offsetWidth;
            container.classList.add('shake');
            flashOverlay.style.opacity = 0.3;
            setTimeout(() => flashOverlay.style.opacity = 0, 150);
        }

        function createLaser(x1, y1, x2, y2) {
            const dist = Math.hypot(x2-x1, y2-y1);
            const ang = Math.atan2(y2-y1, x2-x1);
            const l = document.createElement('div');
            l.className = 'laser-beam';
            l.style.left = x1+'px'; l.style.top = y1+'px';
            l.style.width = dist+'px';
            l.style.transform = `rotate(${ang}rad)`;
            document.body.appendChild(l);
            l.animate([{width:0, opacity:1}, {width:dist+'px', opacity:0}], {duration:200})
             .onfinish = () => l.remove();
        }

        function createParticles(x, y) {
            for(let i=0; i<6; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.width='8px'; p.style.height='8px';
                p.style.background = i%2?'#00f2ff':'#bd00ff';
                p.style.left=x+'px'; p.style.top=y+'px';
                document.body.appendChild(p);
                const a = Math.random()*6.28;
                const d = 30+Math.random()*30;
                p.animate([
                    {transform:'translate(0,0)', opacity:1},
                    {transform:`translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px) scale(0)`, opacity:0}
                ], {duration:400}).onfinish = ()=>p.remove();
            }
        }

        function gameComplete() {
            // 進捗保存
            onGameComplete('spell');
            isGameActive = false;
            stopTimer();
            playSound('complete');

            // 綴り表示オーバーレイを表示
            const revealOverlay = document.getElementById('spell-reveal-overlay');
            const revealContent = document.getElementById('spell-reveal-content');
            revealContent.innerHTML = '';

            LETTERS.forEach((char, index) => {
                const span = document.createElement('span');
                span.className = 'revealed-char';
                span.textContent = char;
                span.style.animationDelay = `${index * 0.1}s`;
                revealContent.appendChild(span);
            });

            revealOverlay.classList.add('show');
            revealOverlay.onclick = () => {
                revealOverlay.classList.remove('show');
                revealOverlay.style.pointerEvents = 'none';
                resultOverlay.classList.add('show');
            };
        }

        window.onload = init;
        window.onresize = () => {};
    </script>
</body>
</html>