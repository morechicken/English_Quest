<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Context Slasher - Sequence</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&family=Shippori+Mincho:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="manifest" href="../manifest.json">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script src="../data/word_data.js"></script>
    <script src="../js/app.js"></script>

    <style>
        body {
            margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden;
            background-color: #000000;
            font-family: 'Montserrat', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
            opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        body.loaded { opacity: 1; }

        #game-stage {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 10;
            padding-bottom: 120px;
        }

        /* 文章コンテナ */
        #sentence-wrapper {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 12px;
            max-width: 90%; perspective: 1000px;
            position: relative;
            line-height: 2.0; 
        }

        .word-unit {
            position: relative;
            font-size: 1.6rem; font-weight: 600; color: #fff;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            padding: 0 2px;
        }

        /* 隠蔽状態 */
        .word-unit.concealed {
            color: transparent;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            filter: blur(8px);
            transform: scale(0.9);
            background: repeating-linear-gradient(45deg, #111, #111 2px, #222 2px, #222 4px);
            -webkit-background-clip: text; background-clip: text;
            opacity: 0.3;
        }

        /* 解放された状態 */
        .word-unit.revealed {
            color: white;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.8);
            filter: blur(0);
            transform: scale(1);
            opacity: 1;
            animation: glitch-reveal 0.3s ease-out;
        }
        @keyframes glitch-reveal {
            0% { transform: translate(-2px, 0); color: #00f2ff; }
            100% { transform: translate(0, 0); color: white; }
        }

        /* ★ターゲット単語（最初から見えている） */
        .word-unit.target-core {
            color: #00f2ff;
            font-weight: 900;
            text-shadow: 0 0 25px #00f2ff;
            z-index: 10;
            opacity: 1;
            filter: blur(0);
            transform: scale(1.1);
        }

        /* 斬撃エフェクト */
        #slash-effect {
            position: absolute; top: 50%; left: 50%;
            width: 200vmax; height: 12px;
            background: #fff;
            box-shadow: 0 0 30px #00f2ff, 0 0 60px #00f2ff, 0 0 100px #fff;
            transform-origin: center;
            transform: translate(-50%, -50%) scaleX(0);
            z-index: 50; pointer-events: none; opacity: 0;
        }
        .slashing #slash-effect {
            animation: slash-anim 0.5s ease-out forwards;
        }
        @keyframes slash-anim {
            0% { transform: translate(-50%, -50%) var(--slash-angle) scaleX(0); opacity: 1; }
            50% { transform: translate(-50%, -50%) var(--slash-angle) scaleX(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) var(--slash-angle) scaleX(1); opacity: 0; }
        }

        #gauge-container {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 400px; height: 40px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #334155; border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 20;
            transition: opacity 0.5s;
        }
        
        #sweet-spot {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 15%;
            transform: translateX(-50%);
            background: rgba(0, 242, 255, 0.2);
            border-left: 2px solid #00f2ff; border-right: 2px solid #00f2ff;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }

        #cursor {
            position: absolute; top: 0; bottom: 0; width: 4px;
            background: white;
            box-shadow: 0 0 10px white;
            left: 0%;
        }

        #instruction {
            position: absolute; bottom: 130px; width: 100%; text-align: center;
            color: #666; font-size: 0.8rem; letter-spacing: 0.2em;
            text-transform: uppercase; pointer-events: none;
            transition: opacity 0.5s;
        }

        #translation {
            margin-top: 40px;
            font-family: 'Shippori Mincho', serif;
            font-size: 1.2rem; color: #aaa;
            opacity: 0; transform: translateY(10px);
            transition: all 1s ease-out;
        }
        #translation.visible { opacity: 1; transform: translateY(0); }

        #continue-msg {
            /* 修正: 100px -> 200px に変更して上に移動 */
            position: absolute; bottom: 200px; width: 100%; text-align: center;
            color: #00f2ff; font-size: 1.2rem; letter-spacing: 0.2em; font-weight: bold;
            opacity: 0; pointer-events: none;
            animation: blink 1.5s infinite;
        }
        #continue-msg.show { opacity: 1; pointer-events: auto; }

        #result-screen {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; opacity: 0; pointer-events: none; transition: opacity 1.0s;
        }
        #result-screen.show { opacity: 1; pointer-events: auto; }
    </style>
</head>
<body>
    <!-- BGM再生用のaudio要素 -->
    <audio id="bgm" loop></audio>
    <div id="game-stage">
        <div id="slash-effect"></div>
        <div id="sentence-wrapper"></div>
        <div id="translation"></div>
    </div>

    <div id="instruction">TAP ON CENTER</div>
    <div id="continue-msg">TAP TO CONTINUE</div>

    <div id="gauge-container">
        <div id="sweet-spot"></div>
        <div id="cursor"></div>
    </div>

    <div id="result-screen">
        <h2 class="text-4xl font-black text-white mb-6 tracking-[0.5em]">DECRYPTED</h2>
        <div class="flex flex-col items-center gap-4">
            <button onclick="location.reload()" class="px-10 py-3 border border-white/30 text-white rounded-full hover:bg-white/10 transition tracking-widest">RETRY</button>
            <button id="back-btn" class="px-10 py-3 bg-cyan-600 text-black font-bold rounded-full shadow-[0_0_20px_rgba(0,242,255,0.5)] transition tracking-widest">NEXT / BACK</button>
        </div>
    </div>

    <script>
        // === 変数 ===
        let wordData = null;
        let TARGET_WORD = "";
        let contextData = null;

        let currentStage = 0;
        const MAX_STAGES = 3;
        let isGameComplete = false;
        let isWaitingForNext = false; 
        let isCoolingDown = false;

        let cursorPosition = 0;
        let cursorDirection = 1;
        let cursorSpeed = 1.1;

        let wrapper, transEl, gaugeContainer, cursorEl, slashEffect;
        let wordSpans = [];

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isAudioInitialized = false;

        // === ユーティリティ：単語数カウント ===
        function countWords(str) {
            if (!str) return 0;
            return str.trim().split(/\s+/).filter(s => s.length > 0).length;
        }

        // === 初期化 ===
        function init() {
            if (typeof getCurrentWordData !== 'function') { console.error("app.js error"); return; }
            wordData = getCurrentWordData();
            if (!wordData) { alert("No Data"); window.location.href = "../list.html"; return; }

            TARGET_WORD = wordData.word;

            // === データの選出ロジック（ここに統合）===
            // 1. 正解データのみを取得
            const correctContexts = wordData.contexts ? wordData.contexts.filter(c => c.is_correct) : [];
            
            // 2. 「ターゲット以外の単語数が3語以上」のものを抽出（長文フィルタ）
            const longContexts = correctContexts.filter(c => {
                const textContent = c.parts.join(" "); 
                return countWords(textContent) >= 3;
            });

            // 3. 条件に合うものがあればそこから、なければ全正解データからランダムに選ぶ
            const sourceList = longContexts.length > 0 ? longContexts : correctContexts;

            if (sourceList.length > 0) {
                contextData = sourceList[Math.floor(Math.random() * sourceList.length)];
            } else {
                // データが全くない場合のフォールバック
                contextData = { full: `The ${TARGET_WORD} is essential.`, jp: "その単語は不可欠だ。" };
            }
            // ==========================================

            wrapper = document.getElementById('sentence-wrapper');
            transEl = document.getElementById('translation');
            gaugeContainer = document.getElementById('gauge-container');
            cursorEl = document.getElementById('cursor');
            slashEffect = document.getElementById('slash-effect');
            document.getElementById('continue-msg').classList.remove('show');
            document.getElementById('back-btn').onclick = () => goTo('../cockpit.html', wordData.id);

            buildSentence();
            setupEvents();
            
            requestAnimationFrame(updateLoop);
            document.body.classList.add('loaded');
        }

        function buildSentence() {
            wrapper.innerHTML = '';
            wordSpans = [];
            const words = contextData.full.split(' ');
            
            words.forEach(word => {
                const span = document.createElement('span');
                
                // ターゲット単語判定
                const cleanWord = word.replace(/[^a-zA-Z]/g, '').toUpperCase();
                const cleanTarget = TARGET_WORD.replace(/[^a-zA-Z]/g, '').toUpperCase();
                
                if (cleanWord === cleanTarget) {
                    // ★ターゲットは最初から見える
                    span.className = 'word-unit target-core';
                } else {
                    // ★他は隠す
                    span.className = 'word-unit concealed';
                }
                span.textContent = word;
                
                wrapper.appendChild(span);
                wordSpans.push(span);
            });
            
            transEl.textContent = contextData.jp;
        }

        function setupEvents() {
            const handleTap = (e) => {
                e.preventDefault();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                isAudioInitialized = true;

                if (isWaitingForNext) {
                    showResult();
                    return;
                }
                if (isGameComplete || isCoolingDown) return;

                checkTiming();
            };

            document.body.addEventListener('pointerdown', handleTap);
            document.body.addEventListener('keydown', (e) => {
                if(e.code === 'Space') handleTap(e);
            });
        }

        function updateLoop() {
            if (!isGameComplete) {
                cursorPosition += cursorSpeed * cursorDirection;
                if (cursorPosition >= 100 || cursorPosition <= 0) cursorDirection *= -1;
                cursorEl.style.left = `${cursorPosition}%`;
            }
            requestAnimationFrame(updateLoop);
        }

        function checkTiming() {
            if (cursorPosition > 42.5 && cursorPosition < 57.5) {
                triggerSlash(true);
            } else {
                triggerSlash(false);
            }
            isCoolingDown = true;
            setTimeout(() => { isCoolingDown = false; }, 400);
        }

        function triggerSlash(isSuccess) {
            if (isSuccess) {
                currentStage++;
                
                // 斬撃の方向（左→中→右）
                let slashX, slashAngle;
                if (currentStage === 1) { slashX = "30%"; slashAngle = "-20deg"; }
                else if (currentStage === 2) { slashX = "50%"; slashAngle = "0deg"; }
                else { slashX = "70%"; slashAngle = "20deg"; }
                
                // エフェクト適用
                slashEffect.style.left = slashX;
                slashEffect.style.top = "50%";
                document.body.style.setProperty('--slash-angle', `rotate(${slashAngle})`);
                
                document.body.classList.remove('slashing');
                void document.body.offsetWidth; // リフロー強制
                document.body.classList.add('slashing');
                
                playSaberSound('hit');
                
                // --- 単語の解放処理 ---
                const totalWords = wordSpans.length;
                const chunkSize = Math.ceil(totalWords / MAX_STAGES);
                const startIndex = (currentStage - 1) * chunkSize;
                const endIndex = Math.min(startIndex + chunkSize, totalWords);

                for (let i = startIndex; i < endIndex; i++) {
                    if (wordSpans[i] && !wordSpans[i].classList.contains('target-core')) {
                        setTimeout(() => {
                            wordSpans[i].classList.remove('concealed');
                            wordSpans[i].classList.add('revealed');
                        }, (i - startIndex) * 50);
                    }
                }

                const shakeX = (Math.random() - 0.5) * 10;
                wrapper.style.transform = `translateX(${shakeX}px)`;
                setTimeout(() => wrapper.style.transform = 'none', 100);

                cursorSpeed *= 1.1;

                // --- ★修正箇所: 終了判定ロジック ---
                // 「すべての単語が表示されたか」をチェック
                // (ターゲット単語は最初から見えているので除外、concealedクラスを持っていないものが全てならOK)
                const allRevealed = wordSpans.every(span => 
                    span.classList.contains('target-core') || span.classList.contains('revealed')
                );

                // もし全部見えたら、MAXステージに達していなくても終了
                // ただし、アニメーションの遅延(setTimeout)を考慮して、少し待ってから判定したいが、
                // ここでは「今回の斬撃で全て対象になった」時点で終了フラグを立てる
                if (endIndex >= totalWords || currentStage >= MAX_STAGES) {
                    triggerComplete(slashAngle);
                }
                // -----------------------------------

            } else {
                playSaberSound('miss');
                gaugeContainer.style.borderColor = '#ff0055';
                setTimeout(() => gaugeContainer.style.borderColor = '#334155', 200);
            }
        }

        function triggerComplete() {
            isGameComplete = true;
            playSaberSound('break');
            
            gaugeContainer.style.opacity = 0;
            document.getElementById('instruction').style.opacity = 0;

            setTimeout(() => {
                transEl.classList.add('visible');
                onGameComplete('context');
                isWaitingForNext = true;
                document.getElementById('continue-msg').classList.add('show');
            }, 800);
        }

        function showResult() {
            document.getElementById('result-screen').classList.add('show');
        }

        function playSaberSound(type) {
            if (!isAudioInitialized) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if (type === 'hit') {
                // 重厚なビームサーベル音
                const osc2 = audioCtx.createOscillator();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, t); 
                osc.frequency.exponentialRampToValueAtTime(30, t + 0.8);

                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(60, t);
                osc2.frequency.exponentialRampToValueAtTime(120, t + 0.1); 
                osc2.frequency.linearRampToValueAtTime(40, t + 0.8);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.exponentialRampToValueAtTime(2500, t + 0.05);
                filter.frequency.exponentialRampToValueAtTime(100, t + 0.8);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.8, t + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain).connect(audioCtx.destination);

                osc.start(t); osc.stop(t + 0.8);
                osc2.start(t); osc2.stop(t + 0.8);

            } else if (type === 'miss') {
                osc.connect(gain).connect(audioCtx.destination);
                osc.type = 'square'; osc.frequency.value = 80;
                g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.15);
                osc.start(t); osc.stop(t+0.15);

            } else if (type === 'break') {
                // クリスタル・チャイム
                const g = audioCtx.createGain();
                g.gain.value = 0.15;
                g.connect(audioCtx.destination);

                const freqs = [1046.50, 1174.66, 1318.51, 1567.98, 1760.00];
                
                freqs.forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    o.type = 'sine';
                    o.frequency.value = freq;
                    const nodeGain = audioCtx.createGain();
                    nodeGain.gain.setValueAtTime(0, t);
                    nodeGain.gain.linearRampToValueAtTime(0.1, t + i * 0.05); 
                    nodeGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5 + i * 0.1);
                    o.connect(nodeGain).connect(g);
                    o.start(t + i * 0.03);
                    o.stop(t + 3.0);
                });
            }
        }

        window.onload = init;
    </script>
</body>
</html>