<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Semantic Breaker - Ethereal Audio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@400;700;800;900&family=Montserrat:wght@400;700;900&family=Shippori+Mincho:wght@500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="manifest" href="../manifest.json">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/icon-192.png"> <meta name="theme-color" content="#0f172a">
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <style>
        body {
            margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden;
            /* 基本フォントをSFセットに */
            font-family: 'Montserrat', 'Zen Kaku Gothic New', sans-serif;
            background-color: #050814;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            touch-action: none; user-select: none; -webkit-user-select: none;
            /* 文字のアンチエイリアスを有効化してクッキリさせる */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            
            opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        body.loaded { opacity: 1; }

        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center;
        }

        .hud-text {
            color: white; text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
            text-align: center; margin-top: 20px; font-family: 'Montserrat', sans-serif;
        }
        
        #guide-text {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-family: 'Montserrat', 'Zen Kaku Gothic New', sans-serif;
            font-size: 0.9rem; letter-spacing: 0.1em;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 0.8; } }

        /* スタート画面 */
        #start-screen {
            position: absolute; inset: 0; background: rgba(5, 8, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; transition: opacity 0.5s;
        }
        #start-screen.hidden { opacity: 0; pointer-events: none; }

        /* 結果画面 */
        #result-screen {
            position: absolute; inset: 0; background: rgba(5, 8, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.5s;
            backdrop-filter: blur(10px);
        }
        #result-screen.show { opacity: 1; pointer-events: auto; }
        
        /* ★Fusion Card (結果表示) のSF化・明朝体排除 */
        .fusion-card {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.05), rgba(189, 0, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px; padding: 40px; text-align: center;
            /* ネオンのような発光シャドウ */
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.1), inset 0 0 20px rgba(0, 242, 255, 0.05);
            transform: scale(0.8); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 90%;
            
            /* ★重要: ここでフォントを強制的にゴシックにする */
            font-family: 'Montserrat', 'Zen Kaku Gothic New', sans-serif !important;
            color: white;
        }
        
        /* カード内の明朝指定クラス(jp-font)があってもゴシックで上書き */
        .fusion-card .jp-font, 
        .fusion-card .jp-font-serif {
            font-family: 'Zen Kaku Gothic New', sans-serif !important;
            font-weight: 700; /* 太字にして視認性アップ */
            letter-spacing: 0.05em;
        }

        /* 英語（Word）をさらに強調 */
        .fusion-card .word-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 15px rgba(34, 211, 238, 0.8);
        }

        #result-screen.show .fusion-card { transform: scale(1); }

        /* 認知ロック用オーバーレイ */
        #cognitive-lock-overlay {
            position: fixed; inset: 0;
            background: rgba(5, 8, 20, 0.7);
            backdrop-filter: blur(5px);
            z-index: 300;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.2s ease-in-out;
        }
        #cognitive-lock-overlay.show { opacity: 1; }

        #cognitive-lock-content {
            text-align: center; color: white;
            transform: scale(0.9); opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
        }
        #cognitive-lock-overlay.show #cognitive-lock-content {
            transform: scale(1); opacity: 1;
        }
    </style>
</head>
<body>
    <header class="fixed w-full top-0 z-50 pointer-events-none p-4 flex justify-end">
        
        <button onclick="history.back()" class="pointer-events-auto text-xs font-bold text-slate-500 border border-slate-600/50 px-3 py-1 rounded hover:bg-slate-800/90 hover:text-white hover:border-cyan-500 transition backdrop-blur-sm">
            BACK
        </button>

    </header>

    <!-- BGM再生用のaudio要素 -->
    <audio id="bgm" loop></audio>

    <canvas id="gameCanvas"></canvas>

    <div id="start-screen">
        <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 mb-8 tracking-tighter italic">SEMANTIC BREAKER</h1>
        <button id="start-btn" class="px-12 py-5 bg-white text-black font-bold rounded-full shadow-[0_0_40px_rgba(0,242,255,0.6)] active:scale-95 transition tracking-[0.2em] hover:bg-cyan-50 text-lg">
            START MISSION
        </button>
        <p class="text-gray-500 mt-4 text-xs">SOUND ON</p>
    </div>

    <div id="ui-layer">
        <div class="hud-text">
            <div class="text-xs tracking-widest text-cyan-300 opacity-70 mb-1">SEMANTIC BREAKER</div>
            <div id="target-count" class="text-xl font-bold">TARGETS: 3</div>
        </div>
        <div id="guide-text">TAP TO SHOOT</div>
    </div>

    <div id="result-screen">
        
        <h2 class="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-300 via-white to-cyan-300 mb-8 tracking-[0.2em] italic drop-shadow-[0_0_10px_rgba(34,211,238,0.5)] animate-pulse">
            MISSION CLEAR
        </h2>
        
        <div class="fusion-card w-full max-w-sm mx-auto backdrop-blur-md">
            
            <div id="result-word-en" class="text-4xl font-black text-white mb-4 tracking-wider uppercase drop-shadow-[0_0_15px_rgba(0,242,255,0.8)]" style="font-family: 'Montserrat', sans-serif;">
                </div>

            <div class="h-px w-24 bg-gradient-to-r from-transparent via-cyan-400 to-transparent mx-auto mb-6 opacity-80 shadow-[0_0_5px_cyan]"></div>

            <div id="result-word-jp" class="text-2xl text-white tracking-wide leading-relaxed drop-shadow-md" style="font-family: 'M PLUS 1p', sans-serif; font-weight: 800;">
                </div>
        </div>
        
        <div class="flex flex-col items-center mt-10 w-full max-w-xs gap-4">
            
            <button onclick="window.location.reload()" class="w-full py-4 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-bold rounded-full shadow-[0_0_20px_rgba(6,182,212,0.4)] active:scale-95 transition tracking-widest border border-cyan-400/30">
                REPLAY
            </button>
            
            <button onclick="goTo('../cockpit.html', wordData.id)" class="w-full py-3 text-cyan-400 font-bold tracking-widest border border-cyan-500/30 rounded-full hover:bg-cyan-900/30 hover:text-white transition text-xs">
                NEXT / BACK
            </button>
        </div>

    </div>

    <!-- 認知ロック用オーバーレイ -->
    <div id="cognitive-lock-overlay">
        <div id="cognitive-lock-content">
            <div id="cognitive-lock-jp" class="text-3xl md:text-4xl font-bold font-serif mb-4 drop-shadow-lg" style="color: #bd00ff; text-shadow: 0 0 15px #bd00ff;"></div>
            <div id="cognitive-lock-en" class="text-4xl md:text-5xl font-black font-montserrat tracking-wider drop-shadow-lg" style="color: #00f2ff; text-shadow: 0 0 15px #00f2ff;"></div>
        </div>
    </div>

<script src="../data/word_data.js"></script>
<script src="../js/app.js"></script>
<script>
        // === 1. データの取得 ===
        const wordData = getCurrentWordData();
        if (!wordData) {
            alert("データが見つかりません。リストに戻ります。");
            window.location.href = "../list.html";
        }

        // === 2. 定数の上書き ===
        const ENGLISH_WORD = wordData.word;
        const allTargetsData = wordData.meanings_expanded || [wordData.meaning_core];
        const TARGETS_DATA = allTargetsData.sort(() => 0.5 - Math.random()).slice(0, 4);

        const COLOR_EN = "#00f2ff"; 
        const COLOR_JP = "#bd00ff";

        // === 変数 ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, cx, cy;

        let gameMode = 'aiming'; 

        let player = { x: 0, y: 0, radius: 35, text: ENGLISH_WORD, color: COLOR_EN };
        let balls = [];
        const BALL_SPEED = 12;

        let targets = [];
        let obstacles = []; // 障害物（釘）
        let particles = [];
        let shakeIntensity = 0;
        let isShooting = false;
        let cognitiveLockTimer = null;

        // === 3. 初期化関数 ===
        function resize() {
            // ★ 高解像度対応の修正ここから ★
            
            // 1. デバイスの画素密度を取得（Retinaなら2など）
            const dpr = window.devicePixelRatio || 1;

            // 2. 論理的なサイズ（CSS上の見た目のサイズ）を設定
            width = window.innerWidth;
            height = window.innerHeight;
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // 3. 内部解像度をdpr倍にする（これで滲みが消える）
            canvas.width = width * dpr;
            canvas.height = height * dpr;

            // 4. 描画コンテキストのスケールを合わせる
            // これにより、座標計算（0〜width）はそのままで、描画だけ高精細になる
            ctx.scale(dpr, dpr);

            // ★ 修正ここまで ★

            cx = width / 2;
            cy = height / 2;
            initPositions();
        }

        function initPositions() {
            player.x = cx;
            player.y = height - 60;

            targets = [];
            obstacles = [];
            balls = [];
            isShooting = false;

            const targetRadius = 40; // ターゲットの半径を小さく
            const targetArea = {
                x: width * 0.1 + targetRadius,
                y: height * 0.1 + targetRadius,
                width: width * 0.8 - targetRadius * 2,
                height: height * 0.5 - targetRadius * 2
            };

            TARGETS_DATA.forEach((text, i) => {
                targets.push({
                    x: targetArea.x + Math.random() * targetArea.width,
                    y: targetArea.y + Math.random() * targetArea.height,
                    radius: targetRadius,
                    color: COLOR_JP,
                    text: text,
                    font: "bold 18px 'Shippori Mincho', serif",
                    alive: true
                });
            });

            // 障害物（釘）を2つ生成
            for (let i = 0; i < 2; i++) {
                obstacles.push({
                    x: cx + (Math.random() - 0.5) * (width * 0.5),
                    y: cy + (Math.random() - 0.5) * (height * 0.3),
                    size: 25, // 立方体のサイズ
                    angle: Math.random() * Math.PI * 2, // 初期角度
                    rotationSpeed: (Math.random() - 0.5) * 0.02, // 回転速度
                    color: 'rgba(150, 200, 255, 0.7)' // ガラスのような色
                });
            }

            // ターゲットや障害物が重ならないように初期位置を調整
            let allObjects = [...targets, ...obstacles.map(o => ({...o, radius: o.size}))]; // 衝突判定用に半径を一時的に設定
            for (let k=0; k<5; k++) { // 5回繰り返して安定させる
                for (let i = 0; i < allObjects.length; i++) {
                    for (let j = i + 1; j < allObjects.length; j++) {
                        const obj1 = allObjects[i];
                        const obj2 = allObjects[j];
                        const dist = Math.hypot(obj1.x - obj2.x, obj1.y - obj2.y);
                        const minDist = obj1.radius + obj2.radius + 20; // 20pxの間隔
                        if (dist < minDist) {
                            const angle = Math.atan2(obj2.y - obj1.y, obj2.x - obj1.x);
                            const overlap = minDist - dist;
                            obj2.x += Math.cos(angle) * overlap * 0.5;
                            obj2.y += Math.sin(angle) * overlap * 0.5;
                            obj1.x -= Math.cos(angle) * overlap * 0.5;
                            obj1.y -= Math.sin(angle) * overlap * 0.5;
                        }
                    }
                }
            }
            
            updateTargetCount();
        }

        function updateTargetCount() {
            const count = targets.filter(t => t.alive).length;
            document.getElementById('target-count').textContent = `TARGETS: ${count}`;
            if (count === 0 && gameMode !== 'clearing') {
                handleComplete();
            }
        }

        window.addEventListener('resize', resize);

        // === 4. Audio System ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isAudioInitialized = false;

        document.getElementById('start-btn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isAudioInitialized = true;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('guide-text').textContent = "TAP TO SHOOT";
        });

        function playSound(type, param) {
            if (!isAudioInitialized) return; 
            const t = audioCtx.currentTime;
            
            if (type === 'shoot') {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.connect(g).connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
                g.gain.setValueAtTime(0.2, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.start(t); osc.stop(t + 0.2);

            } else if (type === 'hit') {
                const osc1 = audioCtx.createOscillator();
                const g1 = audioCtx.createGain();
                osc1.connect(g1).connect(audioCtx.destination);
                osc1.type = 'triangle'; 
                osc1.frequency.setValueAtTime(180, t);
                osc1.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                g1.gain.setValueAtTime(0.5, t);
                g1.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                osc1.start(t); osc1.stop(t + 1.5);

                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.connect(g2).connect(audioCtx.destination);
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(180 * 2.4, t); 
                g2.gain.setValueAtTime(0.2, t);
                g2.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
                osc2.start(t); osc2.stop(t + 1.2);

            } else if (type === 'complete') {
                [261.63, 329.63, 392.00, 523.25].forEach((f, i) => {
                    const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
                    osc.connect(g).connect(audioCtx.destination);
                    osc.type = 'sine'; osc.frequency.value = f;
                    g.gain.setValueAtTime(0, t);
                    g.gain.linearRampToValueAtTime(0.15, t + 0.1 + i*0.05);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 4.0);
                    osc.start(t); osc.stop(t + 4.0);
                });
            }
        }

        // === 5. 操作ロジック ===
        canvas.addEventListener('click', (ev) => {
            ev.preventDefault();
            if (gameMode !== 'aiming' || isShooting) return;

            isShooting = true;
            playSound('shoot');

            const rect = canvas.getBoundingClientRect();
            const clickX = ev.clientX - rect.left;
            const clickY = ev.clientY - rect.top;

            const angle = Math.atan2(clickY - player.y, clickX - player.x);

            balls.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * BALL_SPEED,
                vy: Math.sin(angle) * BALL_SPEED,
                radius: 10, color: player.color,
                life: 150 // 寿命
            });

            // 撃った後のクールダウン
            setTimeout(() => { isShooting = false; }, 300);
        });

        // === 6. メインループ ===
        function update() {
            // ボールの移動と衝突判定
            balls.forEach((ball, ballIndex) => {
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.life--;

                // 壁との反射
                if (ball.x < ball.radius || ball.x > width - ball.radius) ball.vx *= -1;
                if (ball.y < ball.radius || ball.y > height - ball.radius) ball.vy *= -1;

                // ターゲットとの衝突
                targets.forEach(target => {
                    if (!target.alive) return;
                    const dx = target.x - ball.x;
                    const dy = target.y - ball.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = ball.radius + target.radius;

                    if (dist < minDist) {
                        target.alive = false;
                        ball.life = 0; // ボールを消す
                        playSound('hit');
                        shakeIntensity = 10;
                        createExplosion(target.x, target.y, target.color);
                        updateTargetCount();
                        // ★認知ロックを発動
                        showCognitiveLock(target.text);
                    }
                });

                // 障害物との衝突
                obstacles.forEach(obs => {
                    const dx = obs.x - ball.x;
                    const dy = obs.y - ball.y;
                    // 立方体との衝突判定（円で近似）
                    if (Math.hypot(dx, dy) < ball.radius + obs.size / 2) {
                        const angle = Math.atan2(dy, dx);
                        const speed = Math.hypot(ball.vx, ball.vy);
                        ball.vx = -Math.cos(angle) * speed;
                        ball.vy = -Math.sin(angle) * speed;
                        createRingEffect(obs.x, obs.y, '#88aaff');
                    }
                });
            });

            balls = balls.filter(b => b.life > 0);

            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            // 障害物の回転
            obstacles.forEach(obs => {
                obs.angle += obs.rotationSpeed;
            });
        }

        // ★認知ロック表示関数
        function showCognitiveLock(jpText) {
            const overlay = document.getElementById('cognitive-lock-overlay');
            const enEl = document.getElementById('cognitive-lock-en');
            const jpEl = document.getElementById('cognitive-lock-jp');

            // 既存のタイマーがあればクリア
            if (cognitiveLockTimer) clearTimeout(cognitiveLockTimer);

            enEl.textContent = ENGLISH_WORD;
            jpEl.textContent = jpText;
            overlay.classList.add('show');

            cognitiveLockTimer = setTimeout(() => {
                overlay.classList.remove('show');
            }, 1500); // 1.5秒表示
        }

        function handleComplete() {
            gameMode = 'clearing';
            
            // ★進捗保存
            onGameComplete('meaning');
            playSound('complete');
            
            document.getElementById('result-word-en').textContent = ENGLISH_WORD;
            document.getElementById('result-word-jp').innerHTML = TARGETS_DATA.join('<br>');

            setTimeout(() => {
                document.getElementById('result-screen').classList.add('show');
                document.getElementById('guide-text').style.display = 'none';
            }, 500);
        }

        function draw() {
            ctx.fillStyle = 'rgba(5, 8, 20, 0.3)';
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            if (shakeIntensity > 0) {
                const dx = (Math.random() - 0.5) * shakeIntensity;
                const dy = (Math.random() - 0.5) * shakeIntensity;
                ctx.translate(dx, dy);
                shakeIntensity *= 0.9;
            }

            // プレイヤー描画
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 242, 255, 0.1)';
            ctx.fill();
            ctx.strokeStyle = player.color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = "white";
            ctx.font = "bold 14px Montserrat";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.shadowBlur = 0;
            ctx.fillText(player.text, player.x, player.y);

            // ターゲット描画
            targets.forEach(t => {
                if (!t.alive) return;
                ctx.shadowBlur = 15;
                ctx.shadowColor = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(189, 0, 255, 0.1)';
                ctx.fill();
                ctx.strokeStyle = t.color;
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = "white";
                ctx.font = t.font;
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.shadowBlur = 0;
                ctx.fillText(t.text, t.x, t.y);
            });

            // ボールと障害物の描画
            balls.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // 障害物（回転するガラスの立方体）の描画
            obstacles.forEach(obs => {
                ctx.save();
                ctx.translate(obs.x, obs.y);
                ctx.rotate(obs.angle);
                
                const size = obs.size;
                ctx.strokeStyle = obs.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = '#aaccff';
                ctx.shadowBlur = 15;

                // 立方体を描画
                ctx.beginPath();
                ctx.rect(-size / 2, -size / 2, size, size);
                ctx.stroke();

                // 内側の線でガラスっぽさを表現
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.5)';
                ctx.strokeRect(-size/3, -size/3, size*2/3, size*2/3);

                ctx.restore();
            });

            particles.forEach(p => p.draw(ctx));

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        
        function createRingEffect(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push(new Particle(x, y, color, 3.0));
            }
        }

        class Particle {
            constructor(x, y, color, speedScale=1.0) {
                this.x = x; this.y = y; this.color = color;
                const a = Math.random() * Math.PI * 2;
                const s = (Math.random() * 8 + 2) * speedScale;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.92; this.vy *= 0.92;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.random()*3+2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function loop() {
            update();
            draw();
        }
        
        // === 7. スタートアップ ===
        // 初期化はresizeと配置を行う
        resize();
        initPositions();
        loop();

    </script>
</body>
</html>
